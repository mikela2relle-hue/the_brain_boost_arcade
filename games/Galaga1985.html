<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galaga - Retro Edition</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- We'll use Inter as a base, but apply font-mono (Monospace) extensively for retro look -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    <!-- Tailwind Configuration and Custom Styles -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'black-bg': '#000000',
                        'light-gray': '#E0E0E0',
                        'medium-gray': '#AAAAAA',
                        'ship-color': '#FFFFFF',
                        'bullet-color': '#FFFFFF',
                        'enemy-color': '#FF4444', /* Using red for enemies and enemy bullets */
                        'obstacle-color': '#FFFFFF', 
                        'status-ok': '#E0E0E0',
                        'status-alert': '#FF4444', 
                        'status-ready': '#00FF00', // Green is allowed only for status/ready text
                    },
                    fontFamily: {
                        inter: ['Inter', 'sans-serif'],
                        mono: ['Roboto Mono', 'monospace'],
                    },
                },
            },
        }
    </script>

    <style>
        /*
         * MONOCHROME RETRO STYLING 
         * Replaced the neon glow with a sharp, high-contrast border and subtle inner shadow.
         */
        .mono-panel {
            box-shadow: 0 0 0 2px #E0E0E0, inset 0 0 15px rgba(255, 255, 255, 0.05);
            border-radius: 0; /* Sharp corners for retro feel */
        }

        /* Retro Button Styling */
        .mono-button {
            transition: all 0.1s ease-in-out;
            /* Initial state */
            border: 2px solid #E0E0E0;
            color: #E0E0E0;
            background-color: transparent;
            text-shadow: none;
        }

        .mono-button:hover:not(:disabled) {
            /* Hover/Selected State: Inverted colors */
            background-color: #E0E0E0;
            border-color: #000000;
            color: #000000; /* Dark text on light background */
            box-shadow: inset 0 0 5px #AAAAAA;
            transform: scale(1.01);
        }

        .mono-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(100%);
        }

        /* Typography for Data - using light gray and mono font */
        .stat-label {
            color: var(--tw-colors-medium-gray);
            font-weight: 400;
        }

        .stat-value {
            /* This is now the fallback color if no explicit Tailwind class is set */
            color: var(--tw-colors-light-gray);
            font-weight: 700;
            text-shadow: none;
        }
        
        /* Ensure the body takes up the full viewport */
        body {
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--tw-colors-black-bg);
            font-family: 'Roboto Mono', monospace; /* Set global retro font */
        }

        /* Canvas container styles */
        #simulation-viewport {
            position: relative;
            background-color: #000000;
            border-radius: 0;
            flex-grow: 1;
        }
        
        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Menu overlay styling - now only for persistent menus */
        .menu-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.9); 
            z-index: 10;
        }
    </style>
</head>
<body class="bg-black-bg font-mono p-4 sm:p-8">

    <!-- Main Wrapper: Handles the two-column structure and global padding -->
    <div id="main-wrapper" class="flex flex-col lg:flex-row gap-6 max-w-7xl mx-auto w-full h-full lg:h-[800px]">

        <!-- UI/HUD Panel (Left Column) -->
        <div id="ui-panel" class="mono-panel bg-black-bg p-6 lg:w-1/3 flex flex-col space-y-8 min-h-[300px] lg:min-h-full">
            
            <h1 class="text-xl font-bold text-light-gray tracking-wider uppercase text-center border-b pb-3 border-medium-gray">
                // SYSTEM STATUS: LOG
            </h1>

            <!-- Dynamic Status Display (Connected to Game) -->
            <div class="space-y-4">
                <!-- SCORE ROW: Now uses Bright Green and is much larger -->
                <div class="flex justify-between items-center border-b border-medium-gray pb-2">
                    <span class="stat-label text-base uppercase">SCORE</span>
                    <!-- CRITICAL CHANGE: Increased size and set color to text-status-ready -->
                    <span id="score-value" class="stat-value text-status-ready text-4xl font-extrabold">0</span>
                </div>
                
                <div class="flex justify-between items-center border-b border-medium-gray pb-2">
                    <span class="stat-label text-base uppercase">LEVEL</span>
                    <!-- FIX: Added explicit color classes for visibility -->
                    <span id="level-value" class="stat-value text-xl text-light-gray font-bold">1</span>
                </div>

                <div class="flex justify-between items-center border-b border-medium-gray pb-2">
                    <span class="stat-label text-base uppercase">SHIELD</span>
                    <!-- FIX: Added explicit color classes for visibility -->
                    <span id="shield-value" class="stat-value text-xl text-light-gray font-bold">100%</span>
                </div>
                
                <div class="flex justify-between items-center pb-2">
                    <span class="stat-label text-base uppercase">STATUS</span>
                    <span id="status-value" class="stat-value text-xl text-status-ready">SYSTEMS READY</span>
                </div>
            </div>

            <!-- Controls/Instructions -->
            <div class="space-y-4 pt-6 border-t border-medium-gray">
                <h2 class="text-lg font-bold text-light-gray uppercase">Controls</h2>
                <ul class="text-sm space-y-2 text-medium-gray">
                    <!-- CONTROLS UPDATED FOR GALAGA -->
                    <li><span class="text-light-gray font-bold">A/D / ←→</span>: Horizontal Movement</li>
                    <li><span class="text-light-gray font-bold">SPACE</span>: Fire & Start Game</li>
                    <li><span class="text-light-gray font-bold">ENTER</span>: Continue to Next Level</li>
                </ul>
            </div>
            
            <!-- Action Button -->
            <div class="mt-auto pt-6">
                <button id="start-button" class="mono-button w-full py-3 text-lg font-bold tracking-widest uppercase">
                    START / RESTART
                </button>
            </div>
            
        </div>

        <!-- Game Area (Right Column) -->
        <div id="game-wrapper" class="mono-panel bg-black-bg p-0 flex flex-col items-center justify-center relative flex-grow min-h-[500px] lg:min-h-full">
            
            <!-- Canvas for Game Drawing -->
            <div id="simulation-viewport" class="w-full h-full">
                <canvas id="gameCanvas"></canvas>
                
                <!-- Menu Overlay (Initial Screen, Paused, Game Over) -->
                <div id="menu-overlay" class="menu-overlay flex flex-col items-center justify-center text-center p-8 hidden">
                    <h2 id="menu-title" class="text-5xl font-extrabold mb-4 uppercase text-light-gray tracking-wider">
                        GALAGA V1981.01
                    </h2>
                    <p id="menu-subtitle" class="text-xl text-status-ready mb-8">
                        PRESS SPACEBAR TO INITIATE MISSION
                    </p>
                    <p id="menu-instruction" class="text-base text-medium-gray">
                        Use A/D or Arrow Keys for control.
                    </p>
                </div>
            </div>
            
        </div>

    </div>

    <!-- Game Logic -->
    <script type="text/javascript">
        // --- GAME CONSTANTS AND CONFIGURATION ---

        // Game Environment
        const FPS = 60;
        let GAME_WIDTH = 1200; // Updated on resize
        let GAME_HEIGHT = 800; // Updated on resize
        
        // Scaling factor (2.25) applied to all sizes for larger visuals
        const SCALE_FACTOR = 2.25;

        // Ship Constants (Size scaled by 2.25)
        const SHIP_SIZE = 24 * SCALE_FACTOR; // Triangle base (54)
        const SHIP_HEIGHT_RENDER = SHIP_SIZE * 0.75; // Actual rendered height (~40.5)
        const SHIP_SPEED = 7; // Horizontal movement speed
        const SHIP_INVULNERABILITY_TIME = 3 * FPS; // 3 seconds of invulnerability

        // Bullet Constants (Size scaled by 2.25)
        const BULLET_SPEED = 15; // Vertical speed
        const BULLET_WIDTH = 8 * SCALE_FACTOR;
        const BULLET_HEIGHT = 2 * SCALE_FACTOR;
        const PLAYER_FIRE_RATE = 300; // ms (Slower firing rate for Galaga feel)

        // Enemy Constants
        const ENEMY_BASE_SIZE = 10 * SCALE_FACTOR; // 22.5
        const ENEMY_BULLET_SPEED = 7;
        const ENEMY_BULLET_RADIUS = 4;
        const ENEMY_FIRE_CHANCE = 0.005; // Chance per frame for an enemy to fire

        // Wave Configuration
        const WAVE_SIZE = 10;
        const WAVE_BREAK_TIME = 1 * FPS; // Reduced break time for faster testing/flow

        // Scoring (High Magnitude)
        const SCORE_KILL_DRONE = 150;
        const SCORE_KILL_FIGHTER = 400;
        const SCORE_KILL_CRUISER = 750;
        const EXTRA_LIFE_SCORE_THRESHOLD = 10000; // 10,000 points to regain shield chunk

        // Ship State Colors
        const COLOR_NORMAL = tailwind.config.theme.extend.colors['ship-color'];
        const COLOR_DAMAGED = tailwind.config.theme.extend.colors['enemy-color'];
        const COLOR_OBS = tailwind.config.theme.extend.colors['obstacle-color']; // White now

        // --- GLOBAL VARIABLES ---
        let canvas, ctx;
        let gameRunning = false;
        let gamePaused = true;
        let gameStarted = false; // Flag for first-time start
        let level = 1;
        let score = 0;
        let scoreForNextLife = EXTRA_LIFE_SCORE_THRESHOLD; // Tracks score goal for next shield chunk
        
        let ship;
        let bullets = [];
        let enemies = [];
        let enemyBullets = [];
        let explosions = [];
        let canFire = true;
        let waveTimer = 0;

        // Input state 
        let input = {
            left: false, right: false
        };

        // Screen Shake effect
        let screenShakeFrames = 0;
        const SHAKE_INTENSITY = 20; // Max pixel shift
        const SHAKE_DURATION_ON_HIT = 60; // 1 second shake (60 frames)
        
        // --- GAME OBJECTS (Using simple object structures for single-file simplicity) ---

        /** Represents the player's ship (Horizontal movement only) */
        class Ship {
            constructor() {
                // Ship is fixed near the bottom
                this.x = GAME_WIDTH / 2; 
                this.y = GAME_HEIGHT - SHIP_HEIGHT_RENDER * 2;
                this.width = SHIP_SIZE;
                this.height = SHIP_HEIGHT_RENDER; 
                this.hitDelay = 0; // Invulnerability timer
                this.lives = 3; // 3 lives = 100% shield
            }
        }

        /** Represents an enemy bullet */
        class EnemyBullet {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                // Enemy bullets fire straight down
                this.vx = 0; 
                this.vy = ENEMY_BULLET_SPEED;
                this.radius = ENEMY_BULLET_RADIUS;
            }
        }
        
        /** Represents an explosion effect */
        class Explosion {
            constructor(x, y, color = COLOR_DAMAGED) {
                this.x = x;
                this.y = y;
                this.r = 10;
                this.maxR = 60;
                this.opacity = 1.0;
                this.color = color;
            }
        }

        // --- DOM ELEMENTS ---
        const uiElements = {
            score: null, level: null, shield: null, status: null, startButton: null,
            menuOverlay: null, menuTitle: null, menuSubtitle: null, menuInstruction: null
        };

        // --- INITIALIZATION AND SETUP ---

        /** Sets up the canvas and DOM element references */
        function setupCanvas() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            const viewport = document.getElementById('simulation-viewport');
            
            function resizeCanvas() {
                // Adjust canvas size to fit the container
                canvas.width = viewport.clientWidth;
                canvas.height = viewport.clientHeight;
                // Update global reference dimensions
                GAME_WIDTH = canvas.width;
                GAME_HEIGHT = canvas.height;
                // Re-initialize ship position (fixed Y)
                if (ship && gameRunning) initShip();
            }

            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            // Set up DOM references
            uiElements.score = document.getElementById('score-value');
            uiElements.level = document.getElementById('level-value');
            uiElements.shield = document.getElementById('shield-value');
            uiElements.status = document.getElementById('status-value');
            uiElements.startButton = document.getElementById('start-button');
            uiElements.menuOverlay = document.getElementById('menu-overlay');
            uiElements.menuTitle = document.getElementById('menu-title');
            uiElements.menuSubtitle = document.getElementById('menu-subtitle');
            uiElements.menuInstruction = document.getElementById('menu-instruction');

            // Attach event listeners for buttons
            uiElements.startButton.addEventListener('click', handleStartAction);
        }

        /** Initializes the ship state */
        function initShip() {
            // Player ship starts centered, fixed near the bottom
            ship = new Ship();
            ship.x = GAME_WIDTH / 2;
            ship.y = GAME_HEIGHT - SHIP_HEIGHT_RENDER * 2;
        }

        /** Resets all game arrays (enemies, bullets, etc.) */
        function resetGameObjects() {
            enemies = [];
            bullets = [];
            enemyBullets = [];
            // Removed obstacles array
            explosions = [];
        }

        /** Resets input state */
        function resetInputState() {
            input.left = input.right = false;
        }

        /** Initializes or restarts the game */
        function initGame() {
            gameStarted = true;
            gameRunning = true;
            gamePaused = false;
            level = 0; // Will be incremented in nextLevelSetup
            score = 0;
            scoreForNextLife = EXTRA_LIFE_SCORE_THRESHOLD;
            canFire = true;
            waveTimer = 0; // Reset wave timer
            
            initShip();
            resetGameObjects();
            resetInputState();
            
            uiElements.menuOverlay.classList.add('hidden');
            setButtonState(false);
            
            updateHUD();

            // Start the main loop
            if (typeof gameLoopRef === 'undefined') {
                gameLoopRef = setInterval(gameLoop, 1000 / FPS);
            }
            
            // Start the first level
            nextLevelSetup();
        }

        /** Loads the next level, maintaining score/shield */
        function nextLevelSetup() {
            gamePaused = true; 
            level++;
            resetGameObjects();
            resetInputState();
            waveTimer = WAVE_BREAK_TIME; // Start break timer
            waveSpawnIndex = 0; // Reset spawn tracker for new wave
            
            // Ensure the score threshold for the next life is updated if score is already high
            while (score >= scoreForNextLife) {
                scoreForNextLife += EXTRA_LIFE_SCORE_THRESHOLD;
            }
            
            // Show level transition screen
            uiElements.menuTitle.textContent = 'MISSION SUCCESS';
            uiElements.menuSubtitle.textContent = `WAVE ${level - 1} CLEARED. INITIATING MISSION ${level}...`;
            uiElements.menuInstruction.textContent = 'PRESS ENTER TO CONTINUE FLIGHT';
            uiElements.menuOverlay.classList.remove('hidden'); 
            
            setButtonState(false);
            
            updateHUD();
        }

        // --- GAME LOOP AND UPDATES ---

        /** The main game loop */
        function gameLoop() {
            // Apply screen shake if active
            let offsetX = 0, offsetY = 0;
            if (screenShakeFrames > 0) {
                offsetX = Math.random() * SHAKE_INTENSITY * 2 - SHAKE_INTENSITY;
                offsetY = Math.random() * SHAKE_INTENSITY * 2 - SHAKE_INTENSITY;
                screenShakeFrames--;
            }

            ctx.save();
            ctx.translate(offsetX, offsetY);
            
            drawBackground();
            
            if (gameRunning && !gamePaused) {
                // Core Game Updates
                updateShip();
                updateBullets();
                updateEnemies();
                updateExplosions();
                
                // Collision check must happen after all position updates
                checkCollisions(); 
                
                spawnLogic();
                
                // CRITICAL FIX: Check for level completion based on enemies and spawn index
                if (enemies.length === 0 && waveSpawnIndex === WAVE_SIZE) { 
                    waveTimer--;
                    if (waveTimer <= 0) {
                        nextLevelSetup();
                    }
                }

            } else if (!gameRunning && gameStarted) {
                // Game Over screen is displayed, allow explosions to finish
                updateExplosions(); 
            } else {
                // Paused / Menu state: draw static objects
                drawShip(); 
                drawBullets();
                drawEnemies();
            }
            
            updateHUD();
            ctx.restore();
        }

        /** Updates the ship's position and state */
        function updateShip() {
            if (!gameRunning) return;

            // Invulnerability blink timer
            if (ship.hitDelay > 0) {
                ship.hitDelay--;
            }

            // Horizontal Movement Only
            if (input.left) {
                ship.x -= SHIP_SPEED;
            }
            if (input.right) {
                ship.x += SHIP_SPEED;
            }
            
            // Keep ship within horizontal bounds
            const halfWidth = ship.width / 2;
            if (ship.x < halfWidth) ship.x = halfWidth;
            if (ship.x > GAME_WIDTH - halfWidth) ship.x = GAME_WIDTH - halfWidth;
            
            drawShip();
        }

        /** Updates and draws player bullets (Vertical) */
        function updateBullets() {
            bullets = bullets.filter(b => {
                b.y -= BULLET_SPEED; // Move Up
                return b.y > 0; // Keep bullet if within bounds
            });
            drawBullets();
        }

        /** Updates and draws enemy bullets (Vertical) */
        function updateEnemyBullets() {
            enemyBullets = enemyBullets.filter(b => {
                b.y += b.vy; // Move Down
                return b.y < GAME_HEIGHT; // Keep bullet if within bounds
            });
            drawEnemyBullets();
        }

        /** Updates and draws enemies (Wave movement logic) */
        function updateEnemies() {
            enemies = enemies.filter(e => {
                
                // Simple pattern: Enemies move down, stop in attack zone, then retreat/fire
                const ATTACK_Y = GAME_HEIGHT * 0.2; // Fixed Y position for the main enemy formation
                
                if (e.y < ATTACK_Y) {
                    // Phase 1: Move to formation position
                    e.y += 1;
                } else {
                    // Phase 2: Horizontal movement / Firing
                    e.x += Math.sin(Date.now() / 1000 + e.offset) * 0.8; // Simple sine wave horizontal shift

                    // Firing Logic
                    if (gameRunning && Math.random() < ENEMY_FIRE_CHANCE) {
                        fireEnemyBullet(e);
                    }
                }
                
                return true; // Enemies do not despawn unless shot (no world scroll)
            });
            drawEnemies();
            updateEnemyBullets();
        }
        
        /** Removed updateObstacles */
        
        /** Updates explosion effects */
        function updateExplosions() {
            explosions = explosions.filter(e => {
                e.r += 3;
                e.opacity -= 0.05;
                return e.opacity > 0 && e.r < e.maxR;
            });
        }

        // --- DRAWING FUNCTIONS ---

        /** Draws a black background */
        function drawBackground() {
            ctx.fillStyle = tailwind.config.theme.extend.colors['black-bg'];
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        /** Draws the player's ship (Fixed at bottom, horizontal movement) */
        function drawShip() {
            if (ship.hitDelay > 0 && Math.floor(ship.hitDelay / 5) % 2 === 0) {
                // Blink effect during invulnerability
                return;
            }

            const color = (ship.lives <= 1 && ship.hitDelay > 0) ? COLOR_DAMAGED : COLOR_NORMAL;
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;

            // Ship is a vertical-facing, fixed-size rectangle or simple shape
            const halfW = ship.width / 4;
            // Center the drawing point on the ship's actual center (ship.x, ship.y)
            const baseX = ship.x - halfW;
            const baseY = ship.y - ship.height / 2;
            
            ctx.beginPath();
            
            // Draw a basic fixed-screen ship: Square base with a cone top
            ctx.rect(baseX, baseY, halfW * 2, ship.height);
            ctx.stroke();

            // Draw a small cockpit circle
            ctx.beginPath();
            ctx.arc(ship.x, ship.y, halfW / 2, 0, Math.PI * 2);
            ctx.stroke();

        }

        /** Draws player bullets (Vertical) */
        function drawBullets() {
            ctx.fillStyle = tailwind.config.theme.extend.colors['bullet-color'];
            bullets.forEach(b => {
                ctx.fillRect(b.x - BULLET_WIDTH / 2, b.y, BULLET_WIDTH, BULLET_HEIGHT);
            });
        }

        /** Draws enemy bullets (Vertical) */
        function drawEnemyBullets() {
            ctx.fillStyle = tailwind.config.theme.extend.colors['enemy-color'];
            enemyBullets.forEach(b => {
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        /** Draws all enemies (Now using vector shapes for Galaga) */
        function drawEnemies() {
            enemies.forEach(e => {
                ctx.strokeStyle = e.color;
                ctx.lineWidth = e.health < e.maxHealth ? 4 : 2; 

                const halfW = e.width / 2;
                const halfH = e.height / 2;
                const centerX = e.x;
                const centerY = e.y;

                ctx.beginPath();
                
                if (e.type === 'Drone' || e.type === 'Fighter') {
                    // Draw a butterfly/insect shape (simple vector V)
                    ctx.moveTo(centerX - halfW, centerY);
                    ctx.lineTo(centerX, centerY - halfH);
                    ctx.lineTo(centerX + halfW, centerY);
                    ctx.lineTo(centerX, centerY + halfH);
                    ctx.closePath();
                    
                } else if (e.type === 'Cruiser') {
                    // Draw a bulky, square Boss-like ship
                    ctx.rect(centerX - halfW, centerY - halfH, e.width, e.height);
                    
                    // Internal details (wings)
                    ctx.moveTo(centerX - halfW * 1.5, centerY);
                    ctx.lineTo(centerX + halfW * 1.5, centerY);
                }
                
                ctx.stroke();
            });
        }

        /** Removed drawObstacles */

        /** Draws explosion effects */
        function drawExplosions() {
            explosions.forEach(e => {
                ctx.beginPath();
                ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(255, 68, 68, ${e.opacity})`;
                ctx.lineWidth = 4;
                ctx.stroke();
            });
        }
        
        // --- GAME LOGIC AND HELPER FUNCTIONS ---

        /** Sets the disabled state of all interactive buttons */
        function setButtonState(disabled) {
            uiElements.startButton.disabled = disabled;
        }

        /** Handles game over sequence */
        function gameOver() {
            gameRunning = false;
            gamePaused = true;
            
            uiElements.menuTitle.textContent = 'MISSION FAILED';
            uiElements.menuSubtitle.textContent = `FINAL SCORE: ${score.toLocaleString()}`;
            uiElements.menuInstruction.textContent = 'PRESS SPACEBAR TO RESTART';
            uiElements.menuOverlay.classList.remove('hidden');
            
            setButtonState(true);
            updateHUD();
        }
        
        /** Called when the ship is hit by an enemy or bullet */
        function shipHit() {
            if (ship.hitDelay > 0) return; // Already invulnerable

            ship.lives--;
            screenShakeFrames = SHAKE_DURATION_ON_HIT; // Start intense screen shake
            ship.hitDelay = SHIP_INVULNERABILITY_TIME; // 3 seconds of invulnerability
            
            // Create explosion effect at ship location
            explosions.push(new Explosion(ship.x, ship.y));

            if (ship.lives <= 0) {
                gameOver();
            }
        }

        /** Checks for all collisions */
        function checkCollisions() {
            // FIX: Ship collision box needs to be adjusted based on ship's center point
            const shipBox = {
                x: ship.x - SHIP_SIZE / 4, // Approx left edge
                y: ship.y - ship.height / 2, // Approx top edge
                width: SHIP_SIZE / 2, 
                height: ship.height
            };

            // 1. Player Bullet vs. Enemies
            bullets = bullets.filter(b => {
                let hit = false;
                const bulletBox = {x: b.x - BULLET_WIDTH / 2, y: b.y, width: BULLET_WIDTH, height: BULLET_HEIGHT};
                
                // Check against regular enemies
                enemies = enemies.filter(e => {
                    const enemyBox = {
                        x: e.x - e.width / 2, y: e.y - e.height / 2, 
                        width: e.width, height: e.height
                    };
                    if (isColliding(bulletBox, enemyBox)) {
                        hit = true;
                        e.health--;
                        if (e.health <= 0) {
                            handleEnemyDeath(e);
                            return false; // Remove enemy
                        }
                        return true; // Keep enemy
                    }
                    return true;
                });
                
                return !hit; // Keep bullet if it didn't hit anything
            });

            // 2. Ship vs. Enemy Bullets (Only if not invulnerable)
            if (ship.hitDelay === 0) {
                
                // Ship vs. Enemy Bullets
                enemyBullets = enemyBullets.filter(b => {
                    const bulletBox = {x: b.x - b.radius, y: b.y - b.radius, width: b.radius * 2, height: b.radius * 2};
                    if (isColliding(shipBox, bulletBox)) {
                        shipHit();
                        return false; // Remove enemy bullet
                    }
                    return true;
                });

                // Ship vs. Enemies (Collision upon contact)
                enemies.forEach(e => {
                    const enemyBox = {
                        x: e.x - e.width / 2, y: e.y - e.height / 2, 
                        width: e.width, height: e.height
                    };
                    if (isColliding(shipBox, enemyBox)) {
                        shipHit();
                    }
                });
            }
        }
        
        /** Checks for AABB collision */
        function isColliding(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        /** Handles what happens when an enemy is destroyed */
        function handleEnemyDeath(e) {
            let points = SCORE_KILL_DRONE;
            if (e.type === 'Fighter') points = SCORE_KILL_FIGHTER;
            if (e.type === 'Cruiser') points = SCORE_KILL_CRUISER;

            scorePoints(points, e.x, e.y);
            explosions.push(new Explosion(e.x, e.y));
        }

        /** Adds points and checks for shield recovery */
        function scorePoints(amount, x, y) {
            score += amount;
            
            // Check for shield recovery (33% shield restore)
            if (ship.lives < 3 && score >= scoreForNextLife) {
                ship.lives = Math.min(3, ship.lives + 1);
                scoreForNextLife += EXTRA_LIFE_SCORE_THRESHOLD; // Advance threshold
                
                // Add a special explosion effect for recovery
                explosions.push(new Explosion(x, y, COLOR_OBS));
            } else if (score >= scoreForNextLife) {
                // If already max life, just advance the threshold
                 scoreForNextLife += EXTRA_LIFE_SCORE_THRESHOLD;
            }
        }

        /** Spawns a new player bullet (Fires vertically up) */
        function fireBullet() {
            if (canFire) {
                // Player fires from the center top of the ship
                const bulletX = ship.x;
                const bulletY = ship.y - ship.height / 2;
                
                bullets.push({ 
                    x: bulletX, y: bulletY, 
                    width: BULLET_WIDTH, height: BULLET_HEIGHT,
                    hit: false,
                });
                canFire = false;
                setTimeout(() => canFire = true, PLAYER_FIRE_RATE);
            }
        }

        /** Spawns a bullet from an enemy (Fires vertically down) */
        function fireEnemyBullet(source) {
            // Turrets are removed, only enemies fire
            enemyBullets.push(new EnemyBullet(source.x, source.y));
        }

        // --- SPAWNING LOGIC (Wave System) ---
        
        let waveSpawnIndex = 0; // Tracks which enemy in the wave is next
        let timeToNextSpawn = 0;
        
        function spawnLogic() {
            if (enemies.length === 0 && waveSpawnIndex === WAVE_SIZE) {
                // Wave is clear, countdown to next level is happening in gameLoop
                return;
            }

            if (waveSpawnIndex < WAVE_SIZE) {
                // Spawn wave
                timeToNextSpawn--;
                if (timeToNextSpawn <= 0) {
                    spawnWaveEnemy(waveSpawnIndex);
                    waveSpawnIndex++;
                    // Spawn rate increases slightly each level
                    timeToNextSpawn = 30 - (level * 2); 
                }
            }
        }
        
        function spawnWaveEnemy(index) {
            // Determine enemy type based on index (e.g., last two are Cruisers)
            let type = 'Drone';
            let health = 1;

            if (index >= WAVE_SIZE - 2) { 
                type = 'Cruiser'; 
                health = 3;
            } else if (index >= WAVE_SIZE - 5) { 
                type = 'Fighter'; 
                health = 2;
            } 
            // Default is Drone

            // Horizontal position: spread across the top
            const spawnX = GAME_WIDTH / WAVE_SIZE * index + (GAME_WIDTH / (WAVE_SIZE * 2)); 
            const spawnY = -ENEMY_BASE_SIZE * 2; // Start above the screen
            
            spawnEnemy(type, spawnX, spawnY, health);
        }
        
        /** Creates and adds an individual enemy */
        function spawnEnemy(type, x, y, health) {
            let size = ENEMY_BASE_SIZE;
            let height = ENEMY_BASE_SIZE;

            if (type === 'Cruiser') {
                size = 30 * SCALE_FACTOR;
                height = size; 
            } else if (type === 'Drone' || type === 'Fighter') {
                size = ENEMY_BASE_SIZE;
                height = ENEMY_BASE_SIZE; // Use base size for insect enemies
            }
            
            const enemy = {
                x: x, 
                y: y,
                width: size, 
                height: height, 
                vx: 0, vy: 0, 
                type: type,
                health: health,
                maxHealth: health,
                color: (type === 'Cruiser') ? COLOR_NORMAL : COLOR_DAMAGED,
                offset: Math.random() * 100 // For sine movement
            };
            enemies.push(enemy);
        }

        /** Removed obstacle spawning */

        // --- HUD UPDATES ---

        /** Updates the information displayed in the left HUD panel */
        function updateHUD() {
            // Score
            uiElements.score.textContent = score.toLocaleString();

            // Level
            const shieldPercent = Math.max(0, ship.lives * 33);
            uiElements.level.textContent = level;
            uiElements.shield.textContent = `${shieldPercent}%`;
            
            // Status/Game State
            let statusText = 'SYSTEMS READY';
            let statusColor = 'text-status-ready';
            
            if (gameRunning) {
                if (ship.hitDelay > 0) {
                     statusText = 'IMPACT: SHIELD RECALIBRATING';
                     statusColor = 'text-status-alert';
                } else if (enemies.length === 0 && waveSpawnIndex === WAVE_SIZE) {
                     statusText = 'WAVE CLEAR - STANDBY';
                     statusColor = 'text-status-ok';
                } else {
                     statusText = 'MISSION ACTIVE';
                     statusColor = 'text-status-ok';
                }
            } else if (gameStarted) {
                if (ship.lives <= 0) {
                    statusText = 'TERMINATED';
                    statusColor = 'text-status-alert';
                } else if (gamePaused) {
                    statusText = 'HOLD';
                    statusColor = 'text-status-ok'; // Hold is not an error
                }
            } 
            
            uiElements.status.textContent = statusText;
            uiElements.status.className = `stat-value text-xl ${statusColor}`;
            
            // Button Text and State
            if (gameRunning && !gamePaused) {
                uiElements.startButton.textContent = 'PAUSE [P]';
            } else if (gamePaused && gameStarted) {
                if (ship.lives <= 0) {
                     uiElements.startButton.textContent = 'RESTART [SPACE]';
                } else if (level > 0 && enemies.length === 0 && waveSpawnIndex === WAVE_SIZE) {
                     // Condition for Level Complete Pause
                     uiElements.startButton.textContent = 'NEXT MISSION [ENTER]';
                } else {
                     uiElements.startButton.textContent = 'RESUME [SPACE]';
                }
            } else {
                 uiElements.startButton.textContent = 'START / RESTART';
            }
        }

        // --- MENU LOGIC ---
        function drawMenu(title, message, instruction) {
            uiElements.menuTitle.textContent = title;
            uiElements.menuSubtitle.textContent = message;
            uiElements.menuInstruction.textContent = instruction;
            uiElements.menuOverlay.classList.remove('hidden');
        }

        function togglePause() {
            if (gameRunning && !gamePaused) {
                gamePaused = true;
                drawMenu('SYSTEM PAUSED', 'ACTION SUSPENDED', 'PRESS P OR BUTTON TO RESUME FLIGHT');
            } else if (gamePaused) {
                gamePaused = false;
                uiElements.menuOverlay.classList.add('hidden');
                ship.hitDelay = 0; // Clear invulnerability if resuming manually
            }
            updateHUD();
        }

        // --- EVENT HANDLERS ---
        
        /** Handles button click actions */
        function handleStartAction() {
            if (!gameStarted || ship.lives <= 0) {
                initGame(); // START / RESTART
            } else if (gamePaused) {
                // FIX: Check for the level clear condition separately
                if (enemies.length === 0 && waveSpawnIndex === WAVE_SIZE) {
                    // Continuing from Level Complete Screen
                    gamePaused = false;
                    uiElements.menuOverlay.classList.add('hidden');
                    waveTimer = 0; // Ensures the gameLoop doesn't wait for the timer to count down
                } else {
                    // RESUME from manual PAUSE
                    togglePause();
                }
            } else {
                // PAUSE
                togglePause();
            }
        }

        /** Handles keyboard key downs */
        function keyDownHandler(e) {
            // General Controls
            if (e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') input.left = true;
            if (e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') input.right = true;
            
            if (e.key === 'p' || e.key === 'P') togglePause();
            
            // Fire / Start / Resume (SPACEBAR)
            if (e.key === ' ') {
                e.preventDefault(); 
                
                if (!gameRunning || ship.lives <= 0) {
                    initGame();
                } else if (gamePaused) {
                    // Resume from manual pause
                    togglePause();
                } else {
                    fireBullet();
                }
            }

            // Next Level (ENTER)
             if (e.key === 'Enter') {
                e.preventDefault();
                // Check if we are on the Mission Success screen (paused and cleared objects)
                if (gamePaused && enemies.length === 0 && waveSpawnIndex === WAVE_SIZE) {
                    gamePaused = false;
                    uiElements.menuOverlay.classList.add('hidden');
                    waveTimer = 0; // Jump straight into the next level setup
                }
            }
        }

        /** Handles keyboard key ups */
        function keyUpHandler(e) {
            if (e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') input.left = false;
            if (e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') input.right = false;
        }
        
        // --- START GAME ---

        let gameLoopRef;

        window.onload = function () {
            setupCanvas();
            
            // Set initial state before game loop starts
            initShip();
            resetGameObjects();
            updateHUD();
            
            // Ensure the main menu is visible on load
            drawMenu('GALAGA V1981.01', 'PRESS SPACEBAR TO INITIATE MISSION', 'Use A/D or Arrow Keys for control.');
            setButtonState(false); // Enable button for initial start

            // Start the main loop (runs constantly, updates only happen when gameRunning is true)
            gameLoopRef = setInterval(gameLoop, 1000 / FPS);

            // Add input listeners
            document.addEventListener('keydown', keyDownHandler);
            document.addEventListener('keyup', keyUpHandler);
        };
    </script>
</body>
</html>
