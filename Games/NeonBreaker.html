<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meteor Mayhem - Final Version</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the game atmosphere */
        body {
            background-color: #0d0e13;
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.2);
            border-radius: 12px;
            overflow: hidden;
        }

        #game-canvas {
            display: block;
            background-color: #030308; /* Very dark space background */
            border-radius: 12px;
            cursor: crosshair;
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allows clicks to pass through to canvas */
            color: white;
        }
        
        /* Status Bar Styles */
        #status-bar {
            width: 100%;
            height: 50px;
            background-color: rgba(0, 0, 0, 0.9); /* Black Bar */
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 1.5rem;
            box-sizing: border-box;
            border-top-left-radius: 12px;
            border-top-right-radius: 12px;
            border-bottom: 2px solid rgba(0, 255, 255, 0.3);
        }

        #score-display, #powerup-display {
            font-size: 1.2rem;
            font-family: 'mono', monospace;
            color: #0ff;
            font-weight: bold;
        }
        
        #score-display {
            min-width: 150px;
        }

        #health-bar, #gem-slots {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        /* Styles for the health hearts */
        .heart {
            font-size: 1.5rem;
            line-height: 1;
            text-shadow: 0 0 5px rgba(255, 0, 0, 0.5);
            transition: color 0.2s;
        }

        /* Styles for the gem slots */
        .gem-slot {
            width: 18px;
            height: 18px;
            border: 2px solid #555;
            border-radius: 4px;
            background-color: rgba(255, 255, 255, 0.05);
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
            position: relative;
            cursor: help; /* Suggests an interaction */
        }
        
        /* Power-up level indicator on slots */
        .gem-slot::after {
            content: attr(data-level);
            position: absolute;
            top: -15px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.7rem;
            color: #ccc;
            font-family: monospace;
            pointer-events: none;
            display: none;
        }
        .gem-slot:nth-child(1)::after { content: 'LV 1'; display: block; }
        .gem-slot:nth-child(2)::after { content: 'LV 2'; display: block; }
        .gem-slot:nth-child(3)::after { content: 'LV 3'; display: block; }
        .gem-slot:nth-child(4)::after { content: 'LV 4'; display: block; }
        .gem-slot:nth-child(5)::after { content: 'LV 5'; display: block; }


        #message-box {
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(5px);
            padding: 3rem 4rem;
            border-radius: 16px;
            border: 3px solid #0ff;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.6);
            text-align: center;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none; /* Initially hidden */
            pointer-events: auto;
        }

        #message-box h2 {
            font-size: 3rem;
            color: #0ff;
            margin-bottom: 0.75rem;
            text-shadow: 0 0 10px #0ff;
        }

        #message-box p {
            font-size: 1.5rem;
            color: #ccc;
            margin-bottom: 2rem;
        }
        
        .menu-option {
            padding: 0.75rem 1.5rem;
            margin: 10px 0;
            border-radius: 8px;
            font-size: 1.5rem;
            transition: all 0.15s;
            cursor: pointer;
            border: 2px solid transparent;
            color: #fff;
            background-color: rgba(255, 255, 255, 0.1);
            pointer-events: auto;
        }

        .menu-option.selected {
            background-color: #0ff;
            color: #000;
            font-weight: bold;
            box-shadow: 0 0 15px #0ff;
            transform: scale(1.05);
        }
        
        .char-icon {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 15px;
            vertical-align: middle;
            border: 3px solid;
            box-shadow: 0 0 10px;
        }

        /* Score Bonus Text */
        .score-bonus-text {
            position: absolute;
            font-size: 1.1rem;
            font-weight: bold;
            text-shadow: 0 0 5px #ff0;
            opacity: 1;
            transition: all 0.5s ease-out;
            pointer-events: none;
        }
        
        .score-bonus-text.near-miss {
            color: #ffcc00; /* Gold-like color */
        }
        
        .score-bonus-text.meteor-kill {
            color: #00ffaa; /* Cyan/Green for positive hit */
            font-size: 1.2rem;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="game-canvas"></canvas>

    <div id="ui-overlay">
        <div id="status-bar">
            <div class="flex items-center gap-6">
                <div id="score-display">Score: 0</div>
                <div id="health-bar" title="Player Health (Max 3 Hits)"></div>
            </div>
            
            <div id="powerup-display"></div>

            <div id="gem-slots" title="Gems Collected (SHIFT to Activate Powerup)"></div>
        </div>

        <div id="message-box" class="hidden"></div>
    </div>
</div>

<script>
    // --- Global Canvas and Context Setup ---
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    const scoreDisplay = document.getElementById('score-display');
    const healthBar = document.getElementById('health-bar');
    const gemSlotsContainer = document.getElementById('gem-slots');
    const powerupDisplay = document.getElementById('powerup-display');
    const messageBox = document.getElementById('message-box');
    const uiOverlay = document.getElementById('ui-overlay');

    const GAME_WIDTH = 1000;
    const GAME_HEIGHT = 700;
    canvas.width = GAME_WIDTH;
    canvas.height = GAME_HEIGHT;

    // --- Game Constants ---
    const MAX_HEALTH = 3;
    const MAX_GEMS = 5;
    const GEM_COLORS = ['#ff00ff', '#00ffff', '#ffcc00', '#00ff00', '#ff0000']; 
    const PLAYER_OPTIONS = [
        { name: 'Owen', color: '#ff7700' }, // Orange
        { name: 'Caleb', color: '#00aaff' }  // Blue
    ];
    const NEAR_MISS_THRESHOLD = 50; 
    const NEAR_MISS_BONUS = 5;
    const FIRE_RATE = 150; 

    // --- Game State ---
    let player;
    let lasers = [];
    let meteors = [];
    let particles = [];
    let gems = []; 
    let heartPickups = []; 
    let ufo = null; 
    let comet = null; 
    let nextUFOSpawnScore = 500; 
    let nextCometSpawnScore = 1500; 
    let score = 0;
    let lastMeteorTime = 0;
    let lastFireTime = 0;
    let lastTime = 0;
    let meteorSpawnInterval = 1000;
    let nearMisses = new WeakSet();

    // --- UI/Menu State ---
    let gameState = 'HOME'; // 'HOME', 'SELECT', 'PLAY', 'GAME_OVER'
    let menuIndex = 0;
    let menuOptions = [];
    let selectedPlayerColor = PLAYER_OPTIONS[0].color;
    
    // Input state for controls
    const keys = {
        ArrowLeft: false, ArrowRight: false, ArrowUp: false, ArrowDown: false,
        KeyW: false, KeyS: false, KeyA: false, KeyD: false,
        Space: false,
        ShiftLeft: false, ShiftRight: false, 
        Enter: false,
    };
    let isFiring = false; 
    let mouseTargetX = GAME_WIDTH / 2;
    let mouseTargetY = 0; 


    // --- Helper Functions ---
    function degToRad(degrees) {
        return degrees * (Math.PI / 180);
    }

    function showScorePopup(x, y, amount, type) {
        const popup = document.createElement('div');
        popup.textContent = `+${amount}${type === 'near-miss' ? ' NEAR MISS!' : ''}`;
        popup.classList.add('score-bonus-text', type);
        popup.style.left = `${x}px`;
        popup.style.top = `${y}px`;
        uiOverlay.appendChild(popup);

        requestAnimationFrame(() => {
            popup.style.transform = 'translate(-50%, -40px)';
            popup.style.opacity = '0';
        });

        setTimeout(() => popup.remove(), 800);
    }
    
    function showMessage() {
        messageBox.style.display = 'block';
        let content = '';
        
        if (gameState === 'HOME') {
            content = `
                <h2>Meteor Mayhem</h2>
                <p>Use Arrows/WASD to move, Mouse/Space to shoot.<br>
                **Collect gems and press SHIFT for Power-ups!**</p>
                <div id="menu-options"><div class="menu-option" data-action="start">PLAY GAME</div></div>`;
            menuOptions = ['start'];
        } else if (gameState === 'SELECT') {
            content = `
                <h2>Choose Your Pilot</h2>
                <p>Select your ship and press ENTER to start.</p>
                <div id="menu-options">
                    ${PLAYER_OPTIONS.map((p, i) => `
                        <div class="menu-option" data-action="select" data-index="${i}">
                            <span class="char-icon" style="background-color: ${p.color}; border-color: ${p.color}; box-shadow: 0 0 10px ${p.color};"></span>
                            ${p.name}
                        </div>`).join('')}
                </div>`;
            menuOptions = ['select', 'select'];
        } else if (gameState === 'GAME_OVER') {
            content = `
                <h2>GAME OVER</h2>
                <p>You scored: ${score} points!</p>
                <div id="menu-options"><div class="menu-option" data-action="restart">RESTART</div></div>`;
            menuOptions = ['restart'];
        }

        messageBox.innerHTML = content;
        menuIndex = 0;
        updateMenuSelection();
    }
    
    function updateMenuSelection() {
        const options = messageBox.querySelectorAll('.menu-option');
        options.forEach((el, index) => el.classList.toggle('selected', index === menuIndex));
    }
    
    function handleMenuSelection(index) {
        const action = menuOptions[index];
        
        if (gameState === 'HOME' && action === 'start') {
            gameState = 'SELECT';
            showMessage();
        } else if (gameState === 'SELECT' && action === 'select') {
            selectedPlayerColor = PLAYER_OPTIONS[index].color;
            resetGame();
        } else if (gameState === 'GAME_OVER' && action === 'restart') {
            gameState = 'HOME';
            showMessage();
        }
    }

    function hideMessage() {
        messageBox.style.display = 'none';
        menuOptions = [];
    }

    function resetGame() {
        score = 0;
        lasers = [];
        meteors = [];
        particles = [];
        gems = [];
        heartPickups = [];
        ufo = null;
        comet = null;
        meteorSpawnInterval = 1000;
        nextUFOSpawnScore = 500;
        nextCometSpawnScore = 1500;
        nearMisses = new WeakSet();
        
        player = new Player(GAME_WIDTH / 2, GAME_HEIGHT / 2, selectedPlayerColor); 
        
        hideMessage();
        gameState = 'PLAY';
        lastTime = performance.now();
        requestAnimationFrame(gameLoop);
    }
    
    function activatePowerUp() {
        const gemsSpent = player.collectedGems.length;
        if (gemsSpent === 0 || gameState !== 'PLAY' || player.activePowerUpDuration > 0) return;

        const powerUpLevel = gemsSpent;
        const durationMS = 4000 + (powerUpLevel - 1) * 2000;
        const type = ['shield', 'stream', 'helper'][Math.floor(Math.random() * 3)];

        player.resetPowerUp();
        player.activePowerUpDuration = durationMS;
        player.activePowerUpType = type;
        player.powerUpLevel = powerUpLevel;

        if (type === 'shield') {
            player.shieldDuration = durationMS; 
            createExplosion(player.x, player.y, '#00ffff');
        } else if (type === 'stream') {
            createExplosion(player.x, player.y, '#ffaa00');
        } else if (type === 'helper') {
            const numHelpers = Math.ceil(powerUpLevel / 2);
            if (numHelpers >= 3) { // Level 5
                player.helpers.push(new HelperShip(player, -30, 35), new HelperShip(player, 0, 45), new HelperShip(player, 30, 35));
            } else if (numHelpers >= 2) { // Level 3-4
                player.helpers.push(new HelperShip(player, -45, 40), new HelperShip(player, 45, 40));
            } else if (numHelpers >= 1) { // Level 1-2
                player.helpers.push(new HelperShip(player, 90, 30)); 
            }
            createExplosion(player.x, player.y, '#00ff00');
        }
        player.collectedGems = [];
    }
    
    function updateHealthUI() {
        healthBar.innerHTML = '';
        for (let i = 1; i <= MAX_HEALTH; i++) {
            const heart = document.createElement('span');
            heart.classList.add('heart');
            heart.innerHTML = '&#10084;'; 
            heart.style.color = (i <= player.health) ? '#ff0000' : '#333333';
            healthBar.appendChild(heart);
        }
    }

    function updateGemUI() {
        gemSlotsContainer.innerHTML = '';
        for (let i = 0; i < MAX_GEMS; i++) {
            const slot = document.createElement('div');
            slot.classList.add('gem-slot');
            if (i < player.collectedGems.length) {
                const color = player.collectedGems[i];
                slot.style.backgroundColor = color;
                slot.style.borderColor = color;
                slot.style.boxShadow = `0 0 10px ${color}`;
            }
            gemSlotsContainer.appendChild(slot);
        }
    }

    // --- Parallax Stars ---
    class Star {
        constructor(layer) {
            this.x = Math.random() * GAME_WIDTH;
            this.y = Math.random() * GAME_HEIGHT;
            this.radius = layer === 1 ? 0.8 : 1.5;
            this.velocity = layer === 2 ? 1.5 : 1; 
            this.color = layer === 1 ? 'rgba(255, 255, 255, 0.4)' : 'rgba(255, 255, 255, 0.8)';
        }
        update(deltaTime, scrollX, scrollY) {
            this.y += this.velocity * deltaTime * 0.025;
            this.x += scrollX * this.velocity * 0.015; 
            this.y += scrollY * this.velocity * 0.015;
            if (this.y > GAME_HEIGHT) { this.y = 0; this.x = Math.random() * GAME_WIDTH; }
            if (this.y < 0) { this.y = GAME_HEIGHT; this.x = Math.random() * GAME_WIDTH; }
            if (this.x > GAME_WIDTH) { this.x = 0; }
            if (this.x < 0) { this.x = GAME_WIDTH; }
        }
        draw() {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    let stars = [];
    function setupStars() {
        for (let i = 0; i < 200; i++) { stars.push(new Star(1)); }
        for (let i = 0; i < 80; i++) { stars.push(new Star(2)); }
    }
    setupStars();

    // --- Game Object Classes ---

    // 1. Player
    class Player {
        constructor(x, y, shipColor) { 
            this.x = x; this.y = y; this.shipColor = shipColor;
            this.radius = 10; this.baseSpeed = 2; this.speed = this.baseSpeed;
            this.speedIncrement = 0.6; this.lastSpeedScore = 0; this.angle = -90;
            this.health = MAX_HEALTH; this.isShielded = false; this.shieldDuration = 0;
            this.activePowerUpType = null; this.activePowerUpDuration = 0; this.powerUpLevel = 0;
            this.collectedGems = []; this.helpers = []; 
        }
        resetPowerUp() {
            this.isShielded = false; this.shieldDuration = 0;
            this.activePowerUpType = null; this.activePowerUpDuration = 0;
            this.powerUpLevel = 0; this.helpers = [];
        }
        update(deltaTime) {
            const speedLevel = Math.floor(score / 1000);
            if (speedLevel > this.lastSpeedScore) {
                this.speed = this.baseSpeed + (speedLevel * this.speedIncrement);
                this.lastSpeedScore = speedLevel;
            }
            if (keys.ArrowUp || keys.KeyW) this.y -= this.speed;
            if (keys.ArrowDown || keys.KeyS) this.y += this.speed;
            if (keys.ArrowLeft || keys.KeyA) this.x -= this.speed;
            if (keys.ArrowRight || keys.KeyD) this.x += this.speed;
            this.x = Math.max(this.radius, Math.min(this.x, GAME_WIDTH - this.radius));
            this.y = Math.max(this.radius, Math.min(this.y, GAME_HEIGHT - this.radius));
            this.shieldDuration = Math.max(0, this.shieldDuration - deltaTime);
            this.isShielded = this.shieldDuration > 0;
            this.activePowerUpDuration = Math.max(0, this.activePowerUpDuration - deltaTime);
            this.helpers.forEach(h => h.update(this.x, this.y, this.angle)); 
            if (this.activePowerUpDuration <= 0) this.resetPowerUp();
        }
        draw() {
            ctx.save();
            ctx.translate(this.x, this.y);
            const shipSize = this.radius * 2;
            ctx.rotate(degToRad(this.angle + 90)); 
            if (this.isShielded) {
                const shieldPulse = Math.abs(Math.sin(performance.now() / 100));
                ctx.beginPath();
                ctx.arc(0, 0, this.radius * 2.5, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(0, 255, 255, ${0.1 + shieldPulse * 0.1})`;
                ctx.fill();
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 3 + shieldPulse;
                ctx.stroke();
            }
            ctx.beginPath();
            ctx.moveTo(0, -shipSize); ctx.lineTo(-shipSize * 0.7, shipSize); ctx.lineTo(shipSize * 0.7, shipSize);
            ctx.closePath();
            ctx.fillStyle = this.shipColor; ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
            ctx.fill(); ctx.stroke();
            ctx.beginPath(); ctx.arc(0, shipSize, shipSize * 0.4, 0, Math.PI); ctx.fillStyle = '#ff7700'; ctx.fill();
            ctx.restore();
            this.helpers.forEach(h => h.draw());
        }
    }

    // 2. Laser
    class Laser {
        constructor(x, y, angle) {
            this.x = x; this.y = y; this.angle = angle; this.isAlive = true;
            this.speed = 12; this.radius = 2.5;
            this.velocity = { x: Math.cos(degToRad(angle)) * this.speed, y: Math.sin(degToRad(angle)) * this.speed };
        }
        update() { this.x += this.velocity.x; this.y += this.velocity.y; }
        draw() {
            ctx.fillStyle = '#ff00ff'; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill();
            ctx.shadowBlur = 12; ctx.shadowColor = '#ff00ff'; ctx.fillStyle = '#ffffff'; ctx.fillRect(this.x - 1, this.y - 1, 2, 2);
            ctx.shadowBlur = 0;
        }
    }

    // 3. Meteor
    class Meteor {
        constructor(x, y, radius, isLarge = false) {
            this.x = x; this.y = y; this.radius = radius; this.isLarge = isLarge; this.isAlive = true;
            this.velocity = { x: (Math.random() - 0.5) * 1.5, y: 1 + Math.random() * 2 };
            this.color = `rgb(${100 + Math.random() * 50}, ${100 + Math.random() * 50}, ${100 + Math.random() * 50})`;
        }
        update() {
            const speedFactor = player ? player.speed / player.baseSpeed : 1;
            this.x += this.velocity.x * speedFactor * 0.8;
            this.y += this.velocity.y * speedFactor * 0.8;
        }
        draw() {
            ctx.fillStyle = this.color; ctx.strokeStyle = this.isLarge ? '#f00' : '#333'; ctx.lineWidth = this.isLarge ? 4 : 2;
            ctx.beginPath();
            const sides = 8;
            for (let i = 0; i < sides; i++) {
                const angle = (i * (360 / sides) + (this.x * 0.1)) * (Math.PI / 180);
                const r = this.radius + Math.sin(angle * 5) * (this.isLarge ? 5 : 3);
                const pointX = this.x + r * Math.cos(angle);
                const pointY = this.y + r * Math.sin(angle);
                if (i === 0) { ctx.moveTo(pointX, pointY); } else { ctx.lineTo(pointX, pointY); }
            }
            ctx.closePath(); ctx.fill(); ctx.stroke();
        }
    }

    // 4. Particle
    class Particle {
        constructor(x, y, color) {
            this.x = x; this.y = y; this.color = color;
            this.velocity = { x: (Math.random() - 0.5) * (1 + Math.random() * 4), y: (Math.random() - 0.5) * (1 + Math.random() * 4) };
            this.radius = Math.random() * 2.5 + 1; this.life = 100; this.decay = Math.random() * 0.5 + 1.5;
        }
        update() { this.x += this.velocity.x; this.y += this.velocity.y; this.life -= this.decay; }
        draw() {
            // *** FREEZE BUG FIX: Clamp the alpha value to be between 0 and 1 ***
            ctx.globalAlpha = Math.max(0, this.life / 100);
            ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill();
            ctx.globalAlpha = 1;
        }
    }
    
    // 5. Pickups (Gem, Heart)
    class Pickup {
        constructor(x, y, radius) {
            this.x = x; this.y = y; this.radius = radius; this.isAlive = true;
            this.velocity = { x: 0, y: 1 };
        }
        update() {
            this.y += this.velocity.y;
            this.x += Math.sin(this.y * 0.05) * 0.5;
        }
    }
    class Gem extends Pickup {
        constructor(x, y, color) { super(x, y, 10); this.color = color; }
        draw() {
            ctx.fillStyle = this.color; ctx.shadowBlur = 8; ctx.shadowColor = this.color;
            ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill();
            ctx.shadowBlur = 0;
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 1.5; ctx.beginPath();
            ctx.moveTo(this.x - this.radius * 0.5, this.y - this.radius * 0.5);
            ctx.lineTo(this.x + this.radius * 0.5, this.y + this.radius * 0.5); ctx.stroke();
        }
    }
    class HeartPickup extends Pickup {
        constructor(x, y) { super(x, y, 12); }
        draw() {
            ctx.save(); ctx.translate(this.x, this.y);
            ctx.fillStyle = '#ff0000'; ctx.shadowBlur = 10; ctx.shadowColor = '#ff0000';
            ctx.font = '24px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText('â™¥', 0, 0); 
            ctx.restore(); ctx.shadowBlur = 0;
        }
    }
    
    // 6. Special Enemies (UFO, Comet)
    class UFO {
        constructor() {
            this.x = -50; this.y = 50 + Math.random() * 50; this.radius = 30; this.isAlive = true;
            this.width = 60; this.height = 30; this.speed = 3;
        }
        update() { this.x += this.speed; }
        draw() {
            ctx.save(); ctx.translate(this.x, this.y);
            ctx.fillStyle = '#888'; ctx.beginPath(); ctx.ellipse(0, 0, this.width / 2, this.height / 2, 0, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#00ffff'; ctx.globalAlpha = 0.8; ctx.beginPath(); ctx.arc(0, -this.height / 4, this.width / 4, Math.PI, 0); ctx.fill();
            ctx.globalAlpha = 1;
            const pulse = Math.abs(Math.sin(performance.now() / 150)) * 0.5;
            ctx.fillStyle = `rgba(255, 255, 0, ${0.5 + pulse})`; ctx.beginPath();
            ctx.arc(-this.width / 3, this.height / 3, 3, 0, Math.PI * 2); ctx.arc(this.width / 3, this.height / 3, 3, 0, Math.PI * 2); ctx.fill();
            ctx.restore();
        }
    }
    class Comet {
        constructor() {
            this.x = GAME_WIDTH + 50; this.y = GAME_HEIGHT - 50; this.radius = 20; this.speed = 5; this.isAlive = true;
            const targetX = GAME_WIDTH * 0.2, targetY = GAME_HEIGHT * 0.3;
            const angle = Math.atan2(targetY - this.y, targetX - this.x);
            this.velocity = { x: Math.cos(angle) * this.speed, y: Math.sin(angle) * this.speed };
        }
        update() { this.x += this.velocity.x; this.y += this.velocity.y; }
        draw() {
            ctx.save(); ctx.translate(this.x, this.y);
            const angle = Math.atan2(this.velocity.y, this.velocity.x); ctx.rotate(angle);
            const tailLength = 60;
            const tailGradient = ctx.createLinearGradient(0, 0, -tailLength, 0);
            tailGradient.addColorStop(0, 'rgba(255, 255, 255, 1)'); tailGradient.addColorStop(0.5, 'rgba(255, 255, 0, 0.5)'); tailGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(-tailLength, -10); ctx.lineTo(-tailLength, 10); ctx.closePath();
            ctx.fillStyle = tailGradient; ctx.fill();
            ctx.shadowBlur = 15; ctx.shadowColor = '#fff'; ctx.fillStyle = '#ffffff';
            ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI * 2); ctx.fill();
            ctx.restore(); ctx.shadowBlur = 0;
        }
    }
    
    // 7. Helper Ship
    class HelperShip {
        constructor(player, offsetAngle, distance) {
            this.x = player.x; this.y = player.y; this.radius = 6; 
            this.offsetAngle = offsetAngle; this.distance = distance; 
            this.color = player.shipColor;
        }
        update(playerX, playerY, playerAngle) {
            const totalAngle = degToRad(playerAngle + 90 + this.offsetAngle);
            this.x = playerX + Math.cos(totalAngle) * this.distance;
            this.y = playerY + Math.sin(totalAngle) * this.distance;
        }
        draw() {
            ctx.save(); ctx.translate(this.x, this.y);
            ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = this.color; ctx.globalAlpha = 0.8; ctx.fill();
            ctx.globalAlpha = 1; ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.stroke();
            ctx.restore();
        }
    }


    // --- Game Logic ---

    function spawnMeteor() {
        const x = Math.random() * GAME_WIDTH, y = -50;
        const isLarge = Math.random() < 0.1 && score > 500; 
        const radius = isLarge ? 50 + Math.random() * 10 : 15 + Math.random() * 15;
        meteors.push(new Meteor(x, y, radius, isLarge));
    }

    function createExplosion(x, y, color) {
        for (let i = 0; i < 30; i++) {
            particles.push(new Particle(x, y, color));
        }
    }
    
    function handleFiring() {
        const now = performance.now();
        if (isFiring && now - lastFireTime >= FIRE_RATE) {
            lastFireTime = now;
            
            let angle = keys.Space ? -90 : Math.atan2(mouseTargetY - player.y, mouseTargetX - player.x) * (180 / Math.PI);
            player.angle = angle;
            
            lasers.push(new Laser(player.x, player.y, angle));
            
            if (player.activePowerUpType === 'stream') { 
                switch (player.powerUpLevel) {
                    case 5: lasers.push(new Laser(player.x, player.y, angle - 45), new Laser(player.x, player.y, angle + 45));
                    case 4: case 3: lasers.push(new Laser(player.x, player.y, angle - 30), new Laser(player.x, player.y, angle + 30));
                    case 2: case 1: lasers.push(new Laser(player.x, player.y, angle - 15), new Laser(player.x, player.y, angle + 15));
                }
            }
            
            player.helpers.forEach(helper => lasers.push(new Laser(helper.x, helper.y, angle)));
        }
    }

    /**
     * The main game loop logic, now cleaned up and reorganized.
     */
    function updateGame(deltaTime) {
        if (gameState !== 'PLAY' || !player) return;

        // --- SECTION 1: SPAWNING ---
        const now = performance.now();
        if (now - lastMeteorTime > meteorSpawnInterval) {
            spawnMeteor();
            lastMeteorTime = now;
            meteorSpawnInterval = Math.max(150, meteorSpawnInterval - 5);
        }
        if (score >= nextUFOSpawnScore && ufo === null && player.collectedGems.length < MAX_GEMS) {
            ufo = new UFO();
            nextUFOSpawnScore += 500;
        }
        if (score >= nextCometSpawnScore && comet === null) {
            comet = new Comet();
            nextCometSpawnScore += 1500;
        }

        // --- SECTION 2: UPDATES ---
        let starScrollX = 0, starScrollY = 0;
        const starSpeedFactor = player.speed * 0.5;
        if (keys.ArrowLeft || keys.KeyA) starScrollX += starSpeedFactor;
        if (keys.ArrowRight || keys.KeyD) starScrollX -= starSpeedFactor;
        if (keys.ArrowUp || keys.KeyW) starScrollY += starSpeedFactor;
        if (keys.ArrowDown || keys.KeyS) starScrollY -= starSpeedFactor;
        
        handleFiring();
        player.update(deltaTime);
        stars.forEach(s => s.update(deltaTime, starScrollX, starScrollY));
        [lasers, meteors, particles, gems, heartPickups].forEach(arr => arr.forEach(obj => obj.update()));
        if (ufo) ufo.update();
        if (comet) comet.update();

        // --- SECTION 3: COLLISIONS & INTERACTIONS ---
        let newMeteors = [];

        // Meteors vs Player
        for (const meteor of meteors) {
            const distance = Math.hypot(player.x - meteor.x, player.y - meteor.y);
            if (distance < player.radius + meteor.radius) {
                if (player.isShielded) {
                    meteor.isAlive = false;
                    player.shieldDuration = Math.max(0, player.shieldDuration - 1500);
                    createExplosion(meteor.x, meteor.y, '#00ffff');
                } else {
                    player.health--;
                    meteor.isAlive = false;
                    player.resetPowerUp();
                    if (player.collectedGems.length > 0) {
                        player.collectedGems.forEach(color => createExplosion(player.x, player.y, color));
                        player.collectedGems = [];
                    }
                    createExplosion(meteor.x, meteor.y, '#f00');
                    if (player.health <= 0) {
                        gameState = 'GAME_OVER';
                        showMessage();
                        createExplosion(player.x, player.y, '#f00');
                        return; // End update loop immediately
                    }
                }
            } else if (distance < player.radius + meteor.radius + NEAR_MISS_THRESHOLD && !nearMisses.has(meteor)) {
                score += NEAR_MISS_BONUS;
                nearMisses.add(meteor); 
                showScorePopup(meteor.x, meteor.y, NEAR_MISS_BONUS, 'near-miss');
            }
        }

        // Lasers vs Everything
        for (const laser of lasers) {
            for (const meteor of meteors) {
                if (!meteor.isAlive) continue;
                if (Math.hypot(laser.x - meteor.x, laser.y - meteor.y) < laser.radius + meteor.radius) {
                    laser.isAlive = false;
                    meteor.isAlive = false;
                    createExplosion(meteor.x, meteor.y, meteor.color);
                    if (meteor.isLarge) {
                        for (let k = 0; k < 3; k++) {
                            const smaller = new Meteor(meteor.x, meteor.y, meteor.radius / 2.5, false);
                            smaller.velocity.x += (Math.random() - 0.5) * 2.5;
                            smaller.velocity.y -= Math.random() * 1;
                            newMeteors.push(smaller);
                        }
                    }
                    const pointsGained = Math.floor(meteor.radius * (player.speed / player.baseSpeed) * 0.8);
                    score += pointsGained;
                    showScorePopup(meteor.x, meteor.y, pointsGained, 'meteor-kill');
                    break; // Laser can only hit one thing
                }
            }
            if (ufo && laser.isAlive && Math.hypot(laser.x - ufo.x, laser.y - ufo.y) < laser.radius + ufo.radius) {
                laser.isAlive = false; ufo = null; score += 500; createExplosion(laser.x, laser.y, '#00ffff'); showScorePopup(laser.x, laser.y, 500, 'meteor-kill');
            }
            if (comet && laser.isAlive && Math.hypot(laser.x - comet.x, laser.y - comet.y) < laser.radius + comet.radius) {
                laser.isAlive = false; comet = null; score += 250; createExplosion(laser.x, laser.y, '#ffffff'); showScorePopup(laser.x, laser.y, 250, 'meteor-kill');
                heartPickups.push(new HeartPickup(laser.x, laser.y));
            }
        }
        meteors.push(...newMeteors);

        // Player vs Pickups
        for (const gem of gems) {
            if (Math.hypot(player.x - gem.x, player.y - gem.y) < player.radius + gem.radius) {
                gem.isAlive = false;
                if (player.collectedGems.length < MAX_GEMS) player.collectedGems.push(gem.color);
            }
        }
        for (const heart of heartPickups) {
            if (Math.hypot(player.x - heart.x, player.y - heart.y) < player.radius + heart.radius) {
                heart.isAlive = false;
                if (player.health < MAX_HEALTH) player.health++;
            }
        }
        
        // --- SECTION 4: CLEANUP ---
        lasers = lasers.filter(l => l.isAlive && l.x > -10 && l.x < GAME_WIDTH + 10 && l.y > -10 && l.y < GAME_HEIGHT + 10);
        meteors = meteors.filter(m => m.isAlive && m.y < GAME_HEIGHT + m.radius);
        particles = particles.filter(p => p.life > 0);
        gems = gems.filter(g => g.isAlive && g.y < GAME_HEIGHT + g.radius);
        heartPickups = heartPickups.filter(h => h.isAlive && h.y < GAME_HEIGHT + h.radius);
        if (ufo && ufo.x > GAME_WIDTH + 50) ufo = null;
        if (comet && (comet.x < -50 || comet.y < -50)) comet = null;

        // --- SECTION 5: UI UPDATE ---
        scoreDisplay.innerHTML = `Score: ${score} <span class="text-xs text-gray-400">(Speed: ${player.speed.toFixed(1)})</span>`;
        updateHealthUI();
        updateGemUI(); 
        
        let puText = 'Awaiting Gems...';
        if (player.activePowerUpDuration > 0) {
            const time = (player.activePowerUpDuration / 1000).toFixed(1);
            const type = player.activePowerUpType.toUpperCase();
            const level = player.powerUpLevel;
            const color = { shield: '#0ff', stream: '#ffaa00', helper: '#00ff00' }[player.activePowerUpType];
            puText = `<span style="color:${color}; font-weight: bold;">[${type} LV ${level}: ${time}s]</span>`;
        } else if (player.collectedGems.length > 0) {
            puText = `SHIFT for LV ${player.collectedGems.length} Powerup!`;
        }
        powerupDisplay.innerHTML = puText;
    }

    /**
     * Draws all game objects to the canvas.
     */
    function drawGame() {
        ctx.fillStyle = '#030308';
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
        stars.forEach(star => star.draw());
        if (gameState === 'PLAY' || gameState === 'GAME_OVER') {
            [meteors, gems, heartPickups, lasers, particles].forEach(arr => arr.forEach(obj => obj.draw()));
            if (ufo) ufo.draw();
            if (comet) comet.draw();
            if (player) player.draw();
        }
    }

    // --- Main Game Loop ---
    function gameLoop(timestamp) {
        const deltaTime = timestamp - lastTime;
        lastTime = timestamp;
        const safeDeltaTime = Math.min(deltaTime, 100); 
        drawGame();
        if (gameState === 'PLAY') updateGame(safeDeltaTime);
        requestAnimationFrame(gameLoop);
    }
    
    // --- Input Handlers ---
    function handleMenuInput(key) {
        if (!menuOptions.length) return;
        if (key === 'ArrowUp' || key === 'KeyW') menuIndex = (menuIndex - 1 + menuOptions.length) % menuOptions.length;
        if (key === 'ArrowDown' || key === 'KeyS') menuIndex = (menuIndex + 1) % menuOptions.length;
        if (key === 'Enter' || key === 'Space') handleMenuSelection(menuIndex);
        updateMenuSelection();
    }
    window.addEventListener('keydown', (e) => {
        if (gameState !== 'PLAY') {
            if (['ArrowUp', 'ArrowDown', 'KeyW', 'KeyS', 'Enter', 'Space'].includes(e.code)) {
                e.preventDefault(); handleMenuInput(e.code);
            }
            return; 
        }
        if (keys.hasOwnProperty(e.code)) { keys[e.code] = true; e.preventDefault(); }
        if (e.code === 'KeyW') keys.ArrowUp = true; if (e.code === 'KeyS') keys.ArrowDown = true;
        if (e.code === 'KeyA') keys.ArrowLeft = true; if (e.code === 'KeyD') keys.ArrowRight = true;
        if (e.code === 'Space') isFiring = true;
        if ((e.code === 'ShiftLeft' || e.code === 'ShiftRight') && !keys.ShiftLeft && !keys.ShiftRight) {
             keys.ShiftLeft = keys.ShiftRight = true; activatePowerUp();
        }
    });
    window.addEventListener('keyup', (e) => {
        if (keys.hasOwnProperty(e.code)) keys[e.code] = false;
        if (e.code === 'KeyW') keys.ArrowUp = false; if (e.code === 'KeyS') keys.ArrowDown = false;
        if (e.code === 'KeyA') keys.ArrowLeft = false; if (e.code === 'KeyD') keys.ArrowRight = false;
        if (e.code === 'Space') isFiring = false;
        if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') keys.ShiftLeft = keys.ShiftRight = false;
    });
    canvas.addEventListener('mousemove', (e) => {
        if (gameState !== 'PLAY') return;
        const rect = canvas.getBoundingClientRect();
        mouseTargetX = e.clientX - rect.left; mouseTargetY = e.clientY - rect.top;
    });
    canvas.addEventListener('mousedown', () => { if (gameState === 'PLAY') isFiring = true; });
    canvas.addEventListener('mouseup', () => isFiring = false);
    messageBox.addEventListener('click', (e) => {
        const target = e.target.closest('.menu-option');
        if (target) handleMenuSelection(Array.from(target.parentNode.children).indexOf(target));
    });

    // --- Initial setup ---
    window.onload = function() {
        player = new Player(GAME_WIDTH / 2, GAME_HEIGHT / 2, selectedPlayerColor);
        showMessage(); 
        drawGame();
        updateHealthUI(); updateGemUI();
        lastTime = performance.now();
        requestAnimationFrame(gameLoop);
    };
</script>

</body>
</html>